# -*- coding: utf-8 -*-
"""YOLOv5 implementation and Optimization  33fe53

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/yolov5-implementation-and-optimization-33fe53-675b96f5-ef07-4f9d-ac63-0d2a87703ec9.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20250227/auto/storage/goog4_request%26X-Goog-Date%3D20250227T073025Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D360212d873591e39f5155d5ca014deb84d007e14efc0d4317e2d476e99ce97b630f6265bb68a0d77c6ecdac49e6fe8ee5860e5517ac863b57fe03f178ab7266563270c0fb808ff4813a2eab61b5430828c6484a3aefe228c531f4bafea904a3baa60aa9122fff6f512eb3d3316c06701a57b561962b12f72733876749e080792f327db9159b15141cfcc08de4171248b21275dacdbf1393aa572ae9cf55f516dc0c56867840f52322cab8772117a57b934d086232bd59bff059c2d943cd1015d0c0399e42bce955bf7f6771114dcdfa01ea5ab8d3411a60f995d4a36cb6319b418e10fdeb54161827f6bafc46f47281a02b7f8bd2ab8e080c11180b4be754f5a
"""

# IMPORTANT: SOME KAGGLE DATA SOURCES ARE PRIVATE
# RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES.
import kagglehub
kagglehub.login()

# IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES,
# THEN FEEL FREE TO DELETE THIS CELL.
# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON
# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR
# NOTEBOOK.

tensorflow_great_barrier_reef_path = kagglehub.competition_download('tensorflow-great-barrier-reef')

print('Data source import complete.')

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/ultralytics/yolov5
# %cd yolov5
!pip install -r requirements.txt

import pandas as pd
import os
import shutil
from sklearn.model_selection import train_test_split

train_csv_path = '/kaggle/input/tensorflow-great-barrier-reef/train.csv'
test_csv_path = '/kaggle/input/tensorflow-great-barrier-reef/test.csv'
train_images_path = '/kaggle/input/tensorflow-great-barrier-reef/train_images'
dataset_path = '/kaggle/working/dataset'
image_folder = os.path.join(dataset_path, 'images')
label_folder = os.path.join(dataset_path, 'labels')

os.makedirs(os.path.join(image_folder, 'train'), exist_ok=True)
os.makedirs(os.path.join(image_folder, 'val'), exist_ok=True)
os.makedirs(os.path.join(image_folder, 'test'), exist_ok=True)
os.makedirs(os.path.join(label_folder, 'train'), exist_ok=True)
os.makedirs(os.path.join(label_folder, 'val'), exist_ok=True)
os.makedirs(os.path.join(label_folder, 'test'), exist_ok=True)

train_df = pd.read_csv(train_csv_path)
test_df = pd.read_csv(test_csv_path)

train_df = train_df[train_df['annotations'] != '[]']

print(train_df[['video_id', 'video_frame', 'annotations']].head(10))

def convert_to_yolo(x, y, w, h, img_width, img_height):
    x_center = (x + w / 2) / img_width
    y_center = (y + h / 2) / img_height
    w = w / img_width
    h = h / img_height
    return x_center, y_center, w, h

train_set, val_set = train_test_split(train_df, test_size=0.2, random_state=42)

def process_row(row, img_folder, lbl_folder, img_width=1280, img_height=720):
    img_path = os.path.join(train_images_path, f'video_{row["video_id"]}', f'{row["video_frame"]}.jpg')
    annotations = eval(row['annotations'])  # Assuming annotations are stored as a string representation of a list of dictionaries

    if os.path.exists(img_path):
        shutil.copy(img_path, img_folder)

        label_file = os.path.splitext(os.path.basename(img_path))[0] + '.txt'
        with open(os.path.join(lbl_folder, label_file), 'w') as f:
            for ann in annotations:
                if 'x' in ann and 'y' in ann and 'width' in ann and 'height' in ann:
                    bbox = [ann['x'], ann['y'], ann['width'], ann['height']]
                    if not any(pd.isna(bbox)):  # Check if there are no NaN values in bbox
                        x, y, w, h = convert_to_yolo(bbox[0], bbox[1], bbox[2], bbox[3], img_width, img_height)
                        f.write(f"0 {x} {y} {w} {h}\n")  # Assuming single class with id 0
                    else:
                        print(f"Skipping invalid bbox: {bbox}")

train_df.columns

import pandas as pd
import os
import shutil
from sklearn.model_selection import train_test_split
from concurrent.futures import ThreadPoolExecutor, as_completed
from tqdm import tqdm

def process_dataset(df, img_folder, lbl_folder):
    with ThreadPoolExecutor(max_workers=8) as executor:
        futures = [executor.submit(process_row, row, img_folder, lbl_folder) for _, row in df.iterrows()]
        for _ in tqdm(as_completed(futures), total=len(futures)):
            pass

process_dataset(train_set, os.path.join(image_folder, 'train'), os.path.join(label_folder, 'train'))
process_dataset(val_set, os.path.join(image_folder, 'val'), os.path.join(label_folder, 'val'))
process_dataset(test_df, os.path.join(image_folder, 'test'), os.path.join(label_folder, 'test'))

#checking file
label_dir = os.path.join(label_folder, 'train')
label_files = os.listdir(label_dir)
for label_file in label_files[:5]:
    with open(os.path.join(label_dir, label_file), 'r') as f:
        print(f"Contents of {label_file}:")
        print(f.read())

# Create dataset.yaml file
dataset_yaml = f"""
train: {os.path.join(image_folder, 'train')}
val: {os.path.join(image_folder, 'val')}
test: {os.path.join(image_folder, 'test')}
nc: 1
names: ['COTS']
"""
with open(os.path.join(dataset_path, 'dataset.yaml'), 'w') as f:
    f.write(dataset_yaml)

!python train.py --img 640 --batch 16 --epochs 10 --data {os.path.join(dataset_path, 'dataset.yaml')} --weights yolov5s.pt

#optimization
!python train.py --img 640 --batch 64 --epochs 20 --data {os.path.join(dataset_path, 'dataset.yaml')} --weights yolov5s.pt

import os
import torch
from PIL import Image
from torchvision.transforms import functional as F
from utils.general import non_max_suppression
from models.experimental import attempt_load
import matplotlib.pyplot as plt

# Function to plot and display bounding boxes on an image
def plot_results(img_path, model, device):
    img = Image.open(img_path)
    img_tensor = F.to_tensor(img).unsqueeze(0).to(device)

    # Run inference
    pred = model(img_tensor)[0]
    pred = non_max_suppression(pred, conf_thres=0.25, iou_thres=0.45)

    # Visualize predictions
    plt.figure(figsize=(10, 10))
    plt.imshow(img)

    if pred[0] is not None:
        for x1, y1, x2, y2, conf, cls in pred[0]:
            # Scale bounding box coordinates
            x1, y1, x2, y2 = int(x1.item()), int(y1.item()), int(x2.item()), int(y2.item())
            # Draw bounding box
            plt.rectangle((x1, y1), (x2, y2), color='r', linewidth=2)
            plt.text(x1, y1 - 10, f'{int(cls)}: {conf:.2f}', color='r', fontsize=12)

    plt.axis('off')
    plt.show()

# Load trained model
weights_path = '/kaggle/working/yolov5/yolov5s.pt'
model = attempt_load(weights_path)
model.eval()

# Set device
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

# Path to training images
# Get the list of image files from the training images folder, excluding directories
train_image_files = [f for f in os.listdir(train_images_folder) if os.path.isfile(os.path.join(image_folder, f))][:5]


# Plot results for each training image
for img_file in train_image_files:
    img_path = os.path.join(train_images_files, img_file)
    plot_results(img_path, model, device)